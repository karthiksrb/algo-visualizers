import { pathFinders } from '@pathFinder/algorithms';
import { CellType } from '@pathFinder/models/enum';
import { Cell } from '@pathFinder/models';
import { highlightPath } from '@pathFinder/store/path.thunk';

const updateCells = vi.fn(async (grid, cells, cellType = CellType.clear) => {
  if (!Array.isArray(cells)) {
    cells = [cells];
  }

  cells.forEach((cell: Cell) => {
    grid[cell.row][cell.col] = cellType;
  });
});

const maze = [
  [
    1, 0, 0, 3, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    3, 0, 0, 0, 0, 0,
  ],
  [
    0, 3, 0, 3, 0, 3, 0, 3, 3, 3, 0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 0, 3, 3,
  ],
  [
    0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 3, 0,
  ],
  [
    3, 3, 0, 3, 0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 0,
  ],
  [
    0, 0, 0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0,
    3, 0, 3, 0, 0, 0,
  ],
  [
    3, 3, 0, 3, 3, 3, 0, 3, 0, 3, 3, 3, 0, 3, 0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 0,
    3, 0, 3, 3, 3, 0,
  ],
  [
    0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0,
    0, 0, 0, 0, 0, 0,
  ],
  [
    3, 3, 3, 3, 0, 3, 3, 3, 0, 3, 3, 3, 0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0, 3, 3,
    3, 3, 3, 0, 3, 3,
  ],
  [
    0, 3, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0,
    3, 0, 3, 0, 0, 0,
  ],
  [
    0, 3, 3, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0,
    3, 0, 3, 0, 3, 0,
  ],
  [
    0, 0, 0, 0, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    3, 0, 3, 0, 3, 0,
  ],
  [
    0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3,
    3, 0, 3, 3, 3, 3,
  ],
  [
    0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0,
  ],
  [
    3, 3, 0, 3, 0, 3, 3, 3, 0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 0, 3, 0, 3, 3,
    3, 3, 3, 3, 3, 3,
  ],
  [
    0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0,
    0, 0, 0, 0, 0, 0,
  ],
  [
    3, 3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 3, 0, 3, 0, 3, 0, 3, 3, 3, 0, 3, 3, 3, 0,
    3, 0, 3, 3, 3, 3,
  ],
  [
    0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 3, 0,
    3, 0, 0, 0, 0, 0,
  ],
  [
    3, 3, 0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3,
    3, 0, 3, 3, 3, 3,
  ],
  [
    0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
    3, 0, 0, 0, 0, 0,
  ],
  [
    0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0, 3, 3,
    3, 0, 3, 0, 3, 3,
  ],
  [
    0, 3, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
    3, 0, 3, 0, 0, 0,
  ],
  [
    0, 3, 0, 3, 3, 3, 0, 3, 0, 3, 3, 3, 0, 3, 3, 3, 0, 3, 3, 3, 0, 3, 0, 3, 0,
    3, 3, 3, 0, 3, 3,
  ],
  [
    0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 3, 0, 3, 0,
    3, 0, 0, 0, 0, 0,
  ],
  [
    0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0, 3, 0,
    3, 0, 3, 0, 3, 3,
  ],
  [
    0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0,
    3, 0, 3, 0, 0, 0,
  ],
  [
    0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 0, 3, 3,
  ],
  [
    0, 3, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
    0, 0, 0, 0, 0, 2,
  ],
];

const pathFindersFns = [
  pathFinders.get('bfs')!.fn,
  pathFinders.get('dfs')!.fn,
  pathFinders.get('a-star')!.fn,
  pathFinders.get('greedy')!.fn,
];

describe('BFS algorithm', () => {
  it('should solve the maze', async () => {
    for (const pathFinderFn of pathFindersFns) {
      const entry = { row: 0, col: 0 };
      const exit = { row: maze.length - 1, col: maze[0].length - 1 };
      const { grid, parents } = await pathFinderFn({
        grid: maze,
        entry,
        exit,
        updateCells,
      });
      highlightPath(grid, parents, 0);

      expect(grid).toMatchSnapshot();
      expect(parents).toMatchSnapshot();
    }
  });
});
